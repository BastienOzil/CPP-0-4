                          NOTES C++

CPP0 - LES BASES DU C++

NOTIONS CLÉS:
- std::cout/std::endl : Affichage dans le terminal
- std::string : Gestion de chaînes de caractères
- Namespace std:: : Organisation du code
- Classes : Créer des types personnalisés (attributs privés, méthodes publiques)
- Constructeur/Destructeur : Initialisation et nettoyage automatique
- Méthodes const : Garantir qu'une méthode ne modifie pas l'objet
- Membres statiques : Variables/méthodes partagées par toutes les instances
- std::getline() : Lire une ligne complète (espaces inclus)

1. std::cout et std::endl
   - Afficher du texte: std::cout << "texte" << variable << std::endl;
   - Détection automatique du type (pas besoin de %d, %s, etc.)

2. std::string
   - Déclaration: std::string nom = "texte";
   - Opérations: .length(), .find(), [], +, .substr()
   - Gestion automatique de la mémoire

3. Namespace std::
   - Préfixer chaque utilisation: std::cout (recommandé à 42)
   - Éviter "using namespace std;"

4. toupper()/tolower()
   - Convertir un caractère en majuscule/minuscule
   - #include <cctype>
   - Fonctionne sur UN caractère à la fois

5. Classes
   - class NomClasse { private: ...; public: ...; };
   - private: accessible uniquement dans la classe
   - public: accessible de partout
   - Règle: attributs en private, méthodes en public

6. Constructeur et Destructeur
   - Constructeur: NomClasse(void); ou NomClasse(params);
   - Destructeur: ~NomClasse(void);
   - Appelés automatiquement à la création/destruction

7. Méthodes const
   - Syntaxe: TypeRetour methode(params) const { ... }
   - Garantit que la méthode ne modifie pas l'objet
   - Les getters sont généralement const

8. std::getline()
   - std::getline(std::cin, variable);
   - Lit toute la ligne (espaces inclus)

9. Membres statiques
   - Attribut static: partagé par TOUTES les instances
   - Déclaration dans .hpp: static int _compteur;
   - Initialisation dans .cpp (obligatoire): int Classe::_compteur = 0;
   - Méthode static: appelable sans objet (Classe::methode())
   - Méthodes statiques n'ont pas accès à "this"

───────────────────────────────────────────────────────────────────────────────
EXEMPLE GLOBAL CPP0
───────────────────────────────────────────────────────────────────────────────

#include <iostream>
#include <string>
#include <cctype>

class Contact {
private:
    std::string _firstName;
    std::string _lastName;
    static int  _totalContacts;    // Attribut statique

public:
    // Constructeur par défaut
    Contact(void) : _firstName(""), _lastName("") {
        _totalContacts++;
        std::cout << "Contact créé (total: " << _totalContacts << ")" << std::endl;
    }

    // Constructeur paramétré
    Contact(std::string first, std::string last) 
        : _firstName(first), _lastName(last) {
        _totalContacts++;
    }

    // Destructeur
    ~Contact(void) {
        _totalContacts--;
        std::cout << "Contact détruit (reste: " << _totalContacts << ")" << std::endl;
    }

    // Méthodes const (getters)
    std::string getFirstName(void) const { return _firstName; }
    std::string getLastName(void) const { return _lastName; }

    // Setters
    void setFirstName(std::string name) { _firstName = name; }
    void setLastName(std::string name) { _lastName = name; }

    // Méthode statique
    static int getTotalContacts(void) { return _totalContacts; }

    // Afficher en majuscules (utilise toupper)
    void displayUpper(void) const {
        std::string full = _firstName + " " + _lastName;
        for (size_t i = 0; i < full.length(); i++)
            std::cout << (char)toupper(full[i]);
        std::cout << std::endl;
    }
};

// Initialisation du static (OBLIGATOIRE)
int Contact::_totalContacts = 0;

int main() {
    // Test des classes et méthodes
    Contact c1;
    c1.setFirstName("jean");
    c1.setLastName("dupont");

    // Test std::getline
    std::string input;
    std::cout << "Entrez un nom: ";
    std::getline(std::cin, input);

    Contact c2("alice", "martin");

    // Test méthode const
    std::cout << "Prénom: " << c1.getFirstName() << std::endl;

    // Test toupper
    c1.displayUpper();  // Affiche: JEAN DUPONT

    // Test méthode statique
    std::cout << "Total contacts: " << Contact::getTotalContacts() << std::endl;

    return 0;
}

───────────────────────────────────────────────────────────────────────────────
RÉSUMÉ CPP0
───────────────────────────────────────────────────────────────────────────────
- Utiliser std::cout/std::string pour affichage et manipulation de texte
- Classes = attributs (private) + méthodes (public)
- Constructeur/Destructeur gèrent création/destruction automatiquement
- const sur les méthodes qui ne modifient pas l'objet
- static pour partager données/méthodes entre toutes les instances
- Liste d'initialisation pour initialiser les attributs efficacement


═══════════════════════════════════════════════════════════════════════════════
CPP1 - GESTION MÉMOIRE ET RÉFÉRENCES
═══════════════════════════════════════════════════════════════════════════════

NOTIONS CLÉS:
- new/delete : Allocation dynamique sur le heap
- new[]/delete[] : Tableaux dynamiques
- Stack vs Heap : Différences et utilisation
- Références (&) : Alias permanent d'une variable
- Références vs Pointeurs : Quand utiliser chacun
- Références comme membres : Initialisation obligatoire
- Liste d'initialisation : Pour références, const, et performance
- ifstream/ofstream : Lecture/écriture de fichiers
- Pointeurs sur méthodes : (Classe::*ptr)(args)

1. new et delete
   - new Type(params) : alloue sur le heap, retourne un pointeur
   - delete ptr : libère la mémoire et appelle le destructeur
   - OBLIGATOIRE : toujours delete ce qui est alloué avec new
   - Accès via ->

2. new[] et delete[]
   - new Type[N] : alloue un tableau de N objets
   - delete[] ptr : libère le tableau complet
   - NE JAMAIS mélanger: new → delete, new[] → delete[]

3. Stack vs Heap
   - Stack: automatique, rapide, limité, scope local
   - Heap: manuel (new/delete), flexible, plus lent, survit au scope
   - Stack pour durée de vie = fonction
   - Heap pour survivre à la fonction ou taille dynamique

4. Références (&)
   - Type& ref = variable : alias permanent
   - DOIT être initialisée
   - Ne peut JAMAIS être NULL ou réassignée
   - Même adresse mémoire que l'original

5. Références vs Pointeurs
   - Référence: alias permanent, pas NULL, syntaxe transparente
   - Pointeur: peut changer de cible, peut être NULL, besoin de *
   - Référence pour paramètres (éviter copies)
   - Pointeur pour optionnel ou new/delete

6. Références comme membres
   - class MaClasse { Type& _ref; };
   - OBLIGATOIRE: initialiser dans liste d'initialisation
   - MaClasse(Type& obj) : _ref(obj) {}
   - Impossible de réassigner après construction

7. Liste d'initialisation
   - Syntaxe: Constructeur(params) : _attr1(val1), _attr2(val2) {}
   - OBLIGATOIRE pour: références, const, performance optimale
   - Plus efficace que assignation dans le corps

8. ifstream et ofstream
   - #include <fstream>
   - std::ifstream fichier("nom.txt"); // Lecture
   - std::ofstream fichier("nom.txt"); // Écriture
   - .is_open() pour vérifier
   - std::getline(fichier, ligne) pour lire
   - fichier << "texte" pour écrire
   - .close() à la fin

9. Méthodes sur std::string
   - .find(s) : retourne position ou std::string::npos
   - .substr(pos, len) : extraire sous-chaîne
   - .erase(pos, len) : supprimer
   - .insert(pos, s) : insérer

10. Pointeurs sur méthodes
    - Déclaration: void (Classe::*ptr)(params);
    - Assignation: ptr = &Classe::methode;
    - Appel: (objet.*ptr)(args);
    - Tableau possible pour remplacer switch/case

───────────────────────────────────────────────────────────────────────────────
EXEMPLE GLOBAL CPP1
───────────────────────────────────────────────────────────────────────────────

#include <iostream>
#include <string>
#include <fstream>

class Weapon {
private:
    std::string _type;

public:
    Weapon(std::string type) : _type(type) {}
    const std::string& getType(void) const { return _type; }
    void setType(std::string type) { _type = type; }
};

class HumanA {
private:
    std::string _name;
    Weapon&     _weapon;  // Référence: arme OBLIGATOIRE

public:
    // Liste d'initialisation OBLIGATOIRE pour la référence
    HumanA(std::string name, Weapon& weapon) 
        : _name(name), _weapon(weapon) {}

    void attack(void) const {
        std::cout << _name << " attacks with " << _weapon.getType() << std::endl;
    }
};

class HumanB {
private:
    std::string _name;
    Weapon*     _weapon;  // Pointeur: arme OPTIONNELLE

public:
    HumanB(std::string name) : _name(name), _weapon(NULL) {}

    void setWeapon(Weapon& weapon) {
        _weapon = &weapon;
    }

    void attack(void) const {
        if (_weapon)
            std::cout << _name << " attacks with " << _weapon->getType() << std::endl;
        else
            std::cout << _name << " has no weapon!" << std::endl;
    }
};

class Zombie {
private:
    std::string _name;

public:
    Zombie(std::string name) : _name(name) {
        std::cout << _name << " rises from the grave" << std::endl;
    }

    ~Zombie(void) {
        std::cout << _name << " returns to the grave" << std::endl;
    }

    void announce(void) const {
        std::cout << _name << ": BraiiiiinnnzzzZ..." << std::endl;
    }
};

// Fonction retournant un pointeur (new pour survivre au return)
Zombie* newZombie(std::string name) {
    return new Zombie(name);  // Sur le heap
}

// Fonction créant un zombie temporaire
void randomChump(std::string name) {
    Zombie z(name);  // Sur le stack
    z.announce();
}  // z détruit automatiquement ici

// Créer une horde de zombies
Zombie* zombieHorde(int N, std::string name) {
    Zombie* horde = new Zombie[N];  // Tableau dynamique
    for (int i = 0; i < N; i++)
        horde[i] = Zombie(name);
    return horde;
}

// Remplacer dans un fichier
void replaceInFile(const std::string& filename, 
                   const std::string& s1, 
                   const std::string& s2) {
    std::ifstream infile(filename);
    if (!infile.is_open()) {
        std::cerr << "Error opening file" << std::endl;
        return;
    }

    std::string content, line;
    while (std::getline(infile, line))
        content += line + "\n";
    infile.close();

    // Remplacer toutes les occurrences
    size_t pos = 0;
    while ((pos = content.find(s1, pos)) != std::string::npos) {
        content.erase(pos, s1.length());
        content.insert(pos, s2);
        pos += s2.length();
    }

    std::ofstream outfile(filename + ".replace");
    outfile << content;
    outfile.close();
}

// Classe avec pointeurs sur méthodes
class Logger {
public:
    void debug(void) { std::cout << "[DEBUG]" << std::endl; }
    void info(void) { std::cout << "[INFO]" << std::endl; }
    void warning(void) { std::cout << "[WARNING]" << std::endl; }

    void log(std::string level) {
        // Tableau de pointeurs sur méthodes
        void (Logger::*functions[3])(void) = {
            &Logger::debug, &Logger::info, &Logger::warning
        };
        std::string levels[3] = {"DEBUG", "INFO", "WARNING"};

        for (int i = 0; i < 3; i++) {
            if (level == levels[i]) {
                (this->*functions[i])();  // Appel via pointeur
                return;
            }
        }
    }
};

int main() {
    // Test new/delete
    Zombie* heap = newZombie("HeapZombie");
    heap->announce();
    delete heap;  // OBLIGATOIRE

    // Test stack
    randomChump("StackZombie");  // Détruit automatiquement

    // Test new[]/delete[]
    Zombie* horde = zombieHorde(3, "Horde");
    delete[] horde;  // OBLIGATOIRE avec []

    // Test références vs pointeurs
    Weapon sword("sword");
    HumanA alice("Alice", sword);  // Référence: obligatoire
    alice.attack();

    HumanB bob("Bob");  // Pointeur: optionnel
    bob.attack();  // Pas d'arme
    bob.setWeapon(sword);
    bob.attack();  // Maintenant avec arme

    // Test fichiers
    replaceInFile("test.txt", "hello", "bonjour");

    // Test pointeurs sur méthodes
    Logger logger;
    logger.log("DEBUG");
    logger.log("WARNING");

    return 0;
}

───────────────────────────────────────────────────────────────────────────────
RÉSUMÉ CPP1
───────────────────────────────────────────────────────────────────────────────
- new/delete pour allocation heap (survit au scope)
- new[]/delete[] pour tableaux dynamiques (jamais mélanger)
- Références = alias permanent (paramètres, membres)
- Pointeurs = flexible mais plus dangereux (NULL, réassignable)
- Liste d'initialisation obligatoire pour références et const
- ifstream/ofstream pour lire/écrire des fichiers
- Pointeurs sur méthodes pour remplacer switch/case élégamment


═══════════════════════════════════════════════════════════════════════════════
CPP2 - FORME CANONIQUE ET SURCHARGE D'OPÉRATEURS
═══════════════════════════════════════════════════════════════════════════════

NOTIONS CLÉS:
- Forme Canonique Orthodoxe : 4 éléments obligatoires
- Constructeur par copie : Créer un nouvel objet en copiant
- Opérateur d'assignation : Copier vers objet existant
- Constructeurs paramétrés : int, float, etc.
- Surcharge opérateurs : +, -, *, /, <, >, ==, !=, <<
- Pré/post incrémentation : ++a vs a++
- Fonctions statiques : min, max
- Attributs const : Initialisation obligatoire

1. Forme Canonique Orthodoxe (4 éléments)
   - Constructeur par défaut: Classe(void);
   - Constructeur par copie: Classe(const Classe& other);
   - Opérateur d'assignation: Classe& operator=(const Classe& other);
   - Destructeur: ~Classe(void);

2. Constructeur par copie
   - Classe(const Classe& other) : _attr(other._attr) {}
   - Appelé lors de: Classe b = a; ou passage par valeur
   - Paramètre const& pour éviter copie infinie

3. Opérateur d'assignation
   - Classe& operator=(const Classe& other)
   - Étapes: 1) vérifier this != &other, 2) copier, 3) return *this
   - Différent du constructeur par copie (objet déjà existant)

4. Constructeurs paramétrés
   - Classe(int n), Classe(float f), etc.
   - Permettent conversions automatiques

5. Fonctions de conversion
   - int toInt(void) const;
   - float toFloat(void) const;

6. Opérateur << (insertion)
   - EXTERNE à la classe (friend ou public)
   - std::ostream& operator<<(std::ostream& out, const Classe& obj)
   - Retourne out pour chaînage

7. Opérateurs de comparaison
   - bool operator>(const Classe& other) const;
   - Retourne bool, méthode const

8. Opérateurs arithmétiques
   - Classe operator+(const Classe& other) const;
   - Retourne nouveau objet

9. Pré/post incrémentation
   - Pré (++a): Classe& operator++(void) { _val++; return *this; }
   - Post (a++): Classe operator++(int) { Classe tmp(*this); _val++; return tmp; }
   - Préférer pré (plus efficace)

10. Fonctions statiques min/max
    - static Classe& min(Classe& a, Classe& b);
    - static const Classe& min(const Classe& a, const Classe& b);
    - 2 versions (const et non-const)

11. Attributs const
    - const int _value;
    - OBLIGATOIRE: initialiser dans liste d'initialisation
    - Impossible de modifier après construction
    - Pas de setter possible

───────────────────────────────────────────────────────────────────────────────
EXEMPLE GLOBAL CPP2
───────────────────────────────────────────────────────────────────────────────

#include <iostream>
#include <cmath>

// Classe Fixed pour nombres à virgule fixe
class Fixed {
private:
    int                 _value;
    static const int    _fractionalBits = 8;

public:
    // 1. Constructeur par défaut
    Fixed(void) : _value(0) {
        std::cout << "Default constructor" << std::endl;
    }

    // 2. Constructeur par copie
    Fixed(const Fixed& other) : _value(other._value) {
        std::cout << "Copy constructor" << std::endl;
    }

    // 3. Opérateur d'assignation
    Fixed& operator=(const Fixed& other) {
        std::cout << "Copy assignment operator" << std::endl;
        if (this != &other)
            this->_value = other._value;
        return *this;
    }

    // 4. Destructeur
    ~Fixed(void) {
        std::cout << "Destructor" << std::endl;
    }

    // Constructeurs paramétrés
    Fixed(const int n) : _value(n << _fractionalBits) {
        std::cout << "Int constructor" << std::endl;
    }

    Fixed(const float f) : _value(roundf(f * (1 << _fractionalBits))) {
        std::cout << "Float constructor" << std::endl;
    }

    // Conversions
    int toInt(void) const {
        return _value >> _fractionalBits;
    }

    float toFloat(void) const {
        return (float)_value / (1 << _fractionalBits);
    }

    int getRawBits(void) const { return _value; }
    void setRawBits(int const raw) { _value = raw; }

    // Opérateurs de comparaison
    bool operator>(const Fixed& other) const {
        return this->_value > other._value;
    }

    bool operator<(const Fixed& other) const {
        return this->_value < other._value;
    }

    bool operator>=(const Fixed& other) const {
        return this->_value >= other._value;
    }

    bool operator<=(const Fixed& other) const {
        return this->_value <= other._value;
    }

    bool operator==(const Fixed& other) const {
        return this->_value == other._value;
    }

    bool operator!=(const Fixed& other) const {
        return this->_value != other._value;
    }

    // Opérateurs arithmétiques
    Fixed operator+(const Fixed& other) const {
        Fixed result;
        result.setRawBits(this->_value + other._value);
        return result;
    }

    Fixed operator-(const Fixed& other) const {
        Fixed result;
        result.setRawBits(this->_value - other._value);
        return result;
    }

    Fixed operator*(const Fixed& other) const {
        Fixed result;
        long long tmp = (long long)this->_value * other._value;
        result.setRawBits(tmp >> _fractionalBits);
        return result;
    }

    Fixed operator/(const Fixed& other) const {
        Fixed result;
        long long tmp = ((long long)this->_value << _fractionalBits);
        result.setRawBits(tmp / other._value);
        return result;
    }

    // Pré-incrémentation
    Fixed& operator++(void) {
        _value++;
        return *this;
    }

    // Post-incrémentation
    Fixed operator++(int) {
        Fixed tmp(*this);
        _value++;
        return tmp;
    }

    // Pré-décrémentation
    Fixed& operator--(void) {
        _value--;
        return *this;
    }

    // Post-décrémentation
    Fixed operator--(int) {
        Fixed tmp(*this);
        _value--;
        return tmp;
    }

    // Fonctions statiques min/max
    static Fixed& min(Fixed& a, Fixed& b) {
        return (a < b) ? a : b;
    }

    static const Fixed& min(const Fixed& a, const Fixed& b) {
        return (a < b) ? a : b;
    }

    static Fixed& max(Fixed& a, Fixed& b) {
        return (a > b) ? a : b;
    }

    static const Fixed& max(const Fixed& a, const Fixed& b) {
        return (a > b) ? a : b;
    }
};

// Opérateur << (externe)
std::ostream& operator<<(std::ostream& out, const Fixed& fixed) {
    out << fixed.toFloat();
    return out;
}

// Classe Point avec attributs const
class Point {
private:
    Fixed const _x;
    Fixed const _y;

public:
    Point(void) : _x(0), _y(0) {}
    Point(float x, float y) : _x(x), _y(y) {}

    // Constructeur par copie (fonctionne car initialisation)
    Point(const Point& other) : _x(other._x), _y(other._y) {}

    // Opérateur = (ne peut pas modifier const)
    Point& operator=(const Point& other) {
        (void)other;
        return *this;
    }

    ~Point(void) {}

    Fixed getX(void) const { return _x; }
    Fixed getY(void) const { return _y; }
};

int main() {
    // Test forme canonique
    Fixed a;
    Fixed b(10);
    Fixed c(42.42f);
    Fixed d(b);

    a = c;

    // Test opérateurs arithmétiques
    Fixed result = b + c;
    std::cout << b << " + " << c << " = " << result << std::endl;

    result = c - b;
    std::cout << c << " - " << b << " = " << result << std::endl;

    result = b * c;
    std::cout << b << " * " << c << " = " << result << std::endl;

    result = c / b;
    std::cout << c << " / " << b << " = " << result << std::endl;

    // Test comparaisons
    if (b < c)
        std::cout << b << " < " << c << std::endl;

    // Test incrémentation
    std::cout << "b avant: " << b << std::endl;
    std::cout << "++b: " << ++b << std::endl;
    std::cout << "b après: " << b << std::endl;
    std::cout << "b++: " << b++ << std::endl;
    std::cout << "b après: " << b << std::endl;

    // Test min/max
    Fixed& smallest = Fixed::min(b, c);
    Fixed& largest = Fixed::max(b, c);
    std::cout << "Min: " << smallest << ", Max: " << largest << std::endl;

    // Test Point avec const
    Point p1(3.5f, 7.2f);
    Point p2 = p1;  // Copy constructor OK
    Point p3;
    p3 = p1;  // Assignment ne fait rien (const)

    std::cout << "Point: (" << p1.getX() << ", " << p1.getY() << ")" << std::endl;

    return 0;
}

───────────────────────────────────────────────────────────────────────────────
RÉSUMÉ CPP2
───────────────────────────────────────────────────────────────────────────────
- Toujours implémenter les 4 éléments de la forme canonique
- Constructeur par copie crée nouvel objet, operator= modifie existant
- Surcharge opérateurs pour utilisation naturelle (+, -, <, <<, etc.)
- Pré-incrémentation plus efficace que post
- Attributs const doivent être initialisés dans liste d'initialisation
- Fonctions statiques min/max en 2 versions (const et non-const)


═══════════════════════════════════════════════════════════════════════════════
CPP3 - HÉRITAGE
═══════════════════════════════════════════════════════════════════════════════

NOTIONS CLÉS:
- Héritage simple : class Derivee : public Base { };
- protected : Accessible dans la classe ET classes dérivées
- Chaînage constructeurs : Base → Dérivée (création), inverse (destruction)
- Override de méthodes : Remplacer comportement de la base
- Héritage virtuel : virtual public pour éviter copies multiples
- Héritage multiple : Hériter de plusieurs classes
- Problème du diamant : Résolu par héritage virtuel
- Name shadowing : Attribut dérivé masque celui de la base
- Using directive : Résoudre ambiguïtés

1. Niveaux d'accès
   - private: classe uniquement
   - protected: classe + dérivées
   - public: partout

2. Héritage simple
   - class Derivee : public Base { };
   - Hérite attributs et méthodes de Base
   - Peut ajouter nouveaux membres ou override

3. Chaînage constructeurs/destructeurs
   - Construction: Base → Dérivée
   - Destruction: Dérivée → Base (inverse)
   - Appel constructeur base: Derivee() : Base(params) {}

4. Override de méthodes
   - Redéfinir méthode de la base avec même signature
   - L'override cache la version de la base

5. Héritage multiple
   - class D : public B1, public B2 { };
   - Hérite de plusieurs classes simultanément

6. Problème du diamant
   - Sans virtual: deux copies de la classe commune
   - Solution: virtual public dans les classes intermédiaires
   - class ScavTrap : virtual public ClapTrap { };

7. Name shadowing
   - Attribut dérivé avec même nom masque celui de la base
   - Accès base: Base::attribut
   - Accès dérivé: this->attribut

8. Using directive
   - Résoudre ambiguïtés dans héritage multiple
   - using Base::methode;

───────────────────────────────────────────────────────────────────────────────
EXEMPLE GLOBAL CPP3
───────────────────────────────────────────────────────────────────────────────

#include <iostream>
#include <string>

// Classe de base
class ClapTrap {
protected:  // Protected pour permettre accès aux dérivées
    std::string _name;
    unsigned int _HP;
    unsigned int _EP;
    unsigned int _DMG;

public:
    ClapTrap(void) : _name("Unnamed"), _HP(10), _EP(10), _DMG(0) {
        std::cout << "ClapTrap default constructor" << std::endl;
    }

    ClapTrap(const std::string& name) 
        : _name(name), _HP(10), _EP(10), _DMG(0) {
        std::cout << "ClapTrap " << _name << " constructor" << std::endl;
    }

    ClapTrap(const ClapTrap& other)
        : _name(other._name), _HP(other._HP), _EP(other._EP), _DMG(other._DMG) {
        std::cout << "ClapTrap copy constructor" << std::endl;
    }

    ClapTrap& operator=(const ClapTrap& other) {
        if (this != &other) {
            _name = other._name;
            _HP = other._HP;
            _EP = other._EP;
            _DMG = other._DMG;
        }
        return *this;
    }

    virtual ~ClapTrap(void) {
        std::cout << "ClapTrap " << _name << " destructor" << std::endl;
    }

    virtual void attack(const std::string& target) {
        std::cout << "ClapTrap " << _name << " attacks " << target
                  << ", causing " << _DMG << " damage!" << std::endl;
    }

    void takeDamage(unsigned int amount) {
        std::cout << "ClapTrap " << _name << " takes " << amount << " damage!" << std::endl;
        _HP -= amount;
    }

    void beRepaired(unsigned int amount) {
        std::cout << "ClapTrap " << _name << " is repaired for " << amount << "!" << std::endl;
        _HP += amount;
    }
};

// Première classe dérivée
class ScavTrap : virtual public ClapTrap {  // virtual public pour éviter problème diamant
public:
    ScavTrap(void) : ClapTrap() {
        _HP = 100;
        _EP = 50;
        _DMG = 20;
        std::cout << "ScavTrap default constructor" << std::endl;
    }

    ScavTrap(const std::string& name) : ClapTrap(name) {
        _HP = 100;
        _EP = 50;
        _DMG = 20;
        std::cout << "ScavTrap " << _name << " constructor" << std::endl;
    }

    ~ScavTrap(void) {
        std::cout << "ScavTrap " << _name << " destructor" << std::endl;
    }

    // Override de attack
    void attack(const std::string& target) {
        std::cout << "ScavTrap " << _name << " attacks " << target
                  << ", causing " << _DMG << " damage!" << std::endl;
    }

    // Méthode unique à ScavTrap
    void guardGate(void) {
        std::cout << "ScavTrap " << _name << " is now in Gate keeper mode" << std::endl;
    }
};

// Deuxième classe dérivée
class FragTrap : virtual public ClapTrap {  // virtual public
public:
    FragTrap(void) : ClapTrap() {
        _HP = 100;
        _EP = 100;
        _DMG = 30;
        std::cout << "FragTrap default constructor" << std::endl;
    }

    FragTrap(const std::string& name) : ClapTrap(name) {
        _HP = 100;
        _EP = 100;
        _DMG = 30;
        std::cout << "FragTrap " << _name << " constructor" << std::endl;
    }

    ~FragTrap(void) {
        std::cout << "FragTrap " << _name << " destructor" << std::endl;
    }

    // Méthode unique à FragTrap
    void highFivesGuys(void) {
        std::cout << "FragTrap " << _name << " requests high fives!" << std::endl;
    }
};

// Héritage multiple (problème du diamant résolu par virtual)
class DiamondTrap : public ScavTrap, public FragTrap {
private:
    std::string _name;  // Name shadowing

public:
    DiamondTrap(void) : ClapTrap("Unnamed_clap_name") {
        _name = "Unnamed";
        _HP = 100;   // FragTrap
        _EP = 50;    // ScavTrap
        _DMG = 30;   // FragTrap
        std::cout << "DiamondTrap default constructor" << std::endl;
    }

    DiamondTrap(const std::string& name) 
        : ClapTrap(name + "_clap_name")  // Appel direct à ClapTrap (virtual)
        , ScavTrap(), FragTrap() {
        _name = name;
        _HP = 100;
        _EP = 50;
        _DMG = 30;
        std::cout << "DiamondTrap " << _name << " constructor" << std::endl;
    }

    ~DiamondTrap(void) {
        std::cout << "DiamondTrap " << _name << " destructor" << std::endl;
    }

    // Using pour résoudre ambiguïté
    using ScavTrap::attack;

    void whoAmI(void) {
        std::cout << "DiamondTrap name: " << _name << std::endl;
        std::cout << "ClapTrap name: " << ClapTrap::_name << std::endl;
    }
};

int main() {
    std::cout << "=== ClapTrap ===" << std::endl;
    ClapTrap clap("Bob");
    clap.attack("target");
    clap.takeDamage(5);
    clap.beRepaired(3);

    std::cout << "\n=== ScavTrap ===" << std::endl;
    ScavTrap scav("Guardian");
    scav.attack("enemy");
    scav.guardGate();

    std::cout << "\n=== FragTrap ===" << std::endl;
    FragTrap frag("Destroyer");
    frag.attack("enemy");
    frag.highFivesGuys();

    std::cout << "\n=== DiamondTrap ===" << std::endl;
    DiamondTrap diamond("Hero");
    diamond.attack("villain");  // ScavTrap::attack grâce à using
    diamond.guardGate();        // de ScavTrap
    diamond.highFivesGuys();    // de FragTrap
    diamond.whoAmI();           // de DiamondTrap

    std::cout << "\n=== Destruction ===" << std::endl;
    return 0;
}

───────────────────────────────────────────────────────────────────────────────
RÉSUMÉ CPP3
───────────────────────────────────────────────────────────────────────────────
- protected pour attributs destinés aux classes dérivées
- Appeler constructeur de base dans liste d'initialisation
- Ordre: Base → Dérivée (construction), inverse (destruction)
- virtual public pour éviter problème du diamant (copies multiples)
- Using directive pour choisir quelle méthode utiliser (ambiguïtés)
- Name shadowing permet deux attributs avec même nom (Base::attr vs this->attr)


═══════════════════════════════════════════════════════════════════════════════
CPP4 - POLYMORPHISME ET CLASSES ABSTRAITES
═══════════════════════════════════════════════════════════════════════════════

NOTIONS CLÉS:
- Polymorphisme : Traiter objets dérivés via pointeurs/références de base
- Fonctions virtuelles : virtual pour liaison dynamique
- Destructeur virtuel : TOUJOURS virtual dans classe de base (crucial!)
- Liaison dynamique : Appel de la méthode selon type réel (runtime)
- Deep copy : Copie profonde avec allocation mémoire
- Shallow copy : Copie superficielle (pointeurs copiés, danger!)
- Classe abstraite : Contient au moins une fonction virtuelle pure
- Fonction virtuelle pure : virtual void methode() = 0;
- Interface : Classe abstraite pure (que des fonctions virtuelles pures)

1. Polymorphisme
   - Base* ptr = new Derivee();
   - ptr->methode() appelle version de Derivee (si virtual)
   - Permet code générique et extensible

2. Fonctions virtuelles
   - virtual RetourType methode(params);
   - Liaison dynamique: version réelle appelée selon type d'objet
   - Sans virtual: liaison statique (version de Base toujours)

3. Destructeur virtuel (CRUCIAL!)
   - virtual ~Base();
   - OBLIGATOIRE si classe a des fonctions virtual
   - Évite fuites mémoire lors de delete via Base*

4. Deep copy vs Shallow copy
   - Shallow: copie les pointeurs (danger double free)
   - Deep: alloue nouvelle mémoire et copie contenu
   - Implémenter copy constructor et assignment operator

5. Règle des trois
   - Si classe a pointeurs dynamiques, définir:
     1) Destructeur, 2) Copy constructor, 3) Assignment operator

6. Classe abstraite
   - Contient au moins une fonction virtuelle pure (= 0)
   - NE PEUT PAS être instanciée
   - Sert de base/interface pour d'autres classes

7. Fonction virtuelle pure
   - virtual void methode() const = 0;
   - Force classes dérivées à implémenter
   - Rend la classe abstraite

8. Interface
   - Classe avec QUE des fonctions virtuelles pures
   - Convention: préfixe I (IDrawable, IMovable, etc.)
   - Définit contrat que dérivées doivent respecter

───────────────────────────────────────────────────────────────────────────────
EXEMPLE GLOBAL CPP4
───────────────────────────────────────────────────────────────────────────────

#include <iostream>
#include <string>

// Classe Brain pour deep copy
class Brain {
private:
    std::string _ideas[100];

public:
    Brain(void) {
        std::cout << "Brain created" << std::endl;
    }

    // Copy constructor (deep copy)
    Brain(const Brain& other) {
        std::cout << "Brain copied" << std::endl;
        for (int i = 0; i < 100; i++)
            _ideas[i] = other._ideas[i];
    }

    // Assignment operator (deep copy)
    Brain& operator=(const Brain& other) {
        std::cout << "Brain assigned" << std::endl;
        if (this != &other) {
            for (int i = 0; i < 100; i++)
                _ideas[i] = other._ideas[i];
        }
        return *this;
    }

    ~Brain(void) {
        std::cout << "Brain destroyed" << std::endl;
    }

    void setIdea(int index, const std::string& idea) {
        if (index >= 0 && index < 100)
            _ideas[index] = idea;
    }

    std::string getIdea(int index) const {
        if (index >= 0 && index < 100)
            return _ideas[index];
        return "";
    }
};

// Classe abstraite (interface)
class Animal {
protected:
    std::string _type;

public:
    Animal(void) : _type("Animal") {
        std::cout << "Animal constructor" << std::endl;
    }

    Animal(const Animal& other) : _type(other._type) {
        std::cout << "Animal copy constructor" << std::endl;
    }

    Animal& operator=(const Animal& other) {
        if (this != &other)
            _type = other._type;
        return *this;
    }

    // Destructeur virtuel (CRUCIAL!)
    virtual ~Animal(void) {
        std::cout << "Animal destructor" << std::endl;
    }

    // Fonction virtuelle pure (= classe abstraite)
    virtual void makeSound(void) const = 0;

    std::string getType(void) const { return _type; }
};

// Classe concrète avec deep copy
class Dog : public Animal {
private:
    Brain* _brain;

public:
    Dog(void) : Animal() {
        _type = "Dog";
        _brain = new Brain();  // Allocation dynamique
        std::cout << "Dog created" << std::endl;
    }

    // Copy constructor avec DEEP COPY
    Dog(const Dog& other) : Animal(other) {
        std::cout << "Dog copied" << std::endl;
        _brain = new Brain(*other._brain);  // Nouvelle allocation
    }

    // Assignment operator avec DEEP COPY
    Dog& operator=(const Dog& other) {
        std::cout << "Dog assigned" << std::endl;
        if (this != &other) {
            Animal::operator=(other);
            delete _brain;                    // Libérer ancien
            _brain = new Brain(*other._brain);  // Nouveau
        }
        return *this;
    }

    ~Dog(void) {
        delete _brain;  // Libération
        std::cout << "Dog destroyed" << std::endl;
    }

    // Implémentation de la fonction pure
    void makeSound(void) const {
        std::cout << "Woaf! Woaf!" << std::endl;
    }

    Brain* getBrain(void) const { return _brain; }
};

class Cat : public Animal {
private:
    Brain* _brain;

public:
    Cat(void) : Animal() {
        _type = "Cat";
        _brain = new Brain();
        std::cout << "Cat created" << std::endl;
    }

    Cat(const Cat& other) : Animal(other) {
        std::cout << "Cat copied" << std::endl;
        _brain = new Brain(*other._brain);
    }

    Cat& operator=(const Cat& other) {
        std::cout << "Cat assigned" << std::endl;
        if (this != &other) {
            Animal::operator=(other);
            delete _brain;
            _brain = new Brain(*other._brain);
        }
        return *this;
    }

    ~Cat(void) {
        delete _brain;
        std::cout << "Cat destroyed" << std::endl;
    }

    void makeSound(void) const {
        std::cout << "Miaou! Miaou!" << std::endl;
    }

    Brain* getBrain(void) const { return _brain; }
};

// Classe WrongAnimal (sans virtual pour comparaison)
class WrongAnimal {
protected:
    std::string _type;

public:
    WrongAnimal(void) : _type("WrongAnimal") {}
    ~WrongAnimal(void) {}  // Pas virtual!

    void makeSound(void) const {  // Pas virtual!
        std::cout << "Wrong Animal sound" << std::endl;
    }

    std::string getType(void) const { return _type; }
};

class WrongCat : public WrongAnimal {
public:
    WrongCat(void) : WrongAnimal() {
        _type = "WrongCat";
    }

    void makeSound(void) const {
        std::cout << "Wrong Miaou!" << std::endl;
    }
};

int main() {
    std::cout << "=== Test polymorphisme avec virtual ===" << std::endl;
    const Animal* animals[4];
    
    // Créer moitié Dogs, moitié Cats
    for (int i = 0; i < 2; i++)
        animals[i] = new Dog();
    for (int i = 2; i < 4; i++)
        animals[i] = new Cat();

    // Polymorphisme: appelle bonne méthode selon type réel
    for (int i = 0; i < 4; i++) {
        std::cout << animals[i]->getType() << ": ";
        animals[i]->makeSound();  // Dog: Woaf, Cat: Miaou
    }

    // Test deep copy
    std::cout << "\n=== Test deep copy ===" << std::endl;
    Dog dog1;
    dog1.getBrain()->setIdea(0, "I want food");
    
    Dog dog2 = dog1;  // Copy constructor (deep copy)
    dog2.getBrain()->setIdea(0, "I want to play");
    
    std::cout << "Dog1 idea: " << dog1.getBrain()->getIdea(0) << std::endl;
    std::cout << "Dog2 idea: " << dog2.getBrain()->getIdea(0) << std::endl;
    // Chaque Dog a son propre Brain indépendant

    // Nettoyage (destructeur virtuel important!)
    std::cout << "\n=== Destruction with virtual ===" << std::endl;
    for (int i = 0; i < 4; i++)
        delete animals[i];  // Appelle bon destructeur grâce à virtual!

    // Test sans virtual (mauvais comportement)
    std::cout << "\n=== Test SANS virtual (mauvais) ===" << std::endl;
    const WrongAnimal* wa = new WrongAnimal();
    const WrongAnimal* wc = new WrongCat();
    
    wa->makeSound();  // Wrong Animal sound
    wc->makeSound();  // Wrong Animal sound (pas Wrong Miaou!)
    // Sans virtual, toujours la méthode de WrongAnimal

    delete wa;
    delete wc;

    std::cout << "\n=== Test classe abstraite ===" << std::endl;
    // Animal* a = new Animal();  // ERREUR: Animal est abstraite!
    Animal* d = new Dog();  // OK: Dog implémente makeSound()
    d->makeSound();
    delete d;

    return 0;
}

───────────────────────────────────────────────────────────────────────────────
RÉSUMÉ CPP4
───────────────────────────────────────────────────────────────────────────────
- TOUJOURS virtual sur destructeur si classe a méthodes virtual
- Polymorphisme = Base* ptr = new Derivee(); avec virtual
- Deep copy obligatoire si classe a pointeurs (règle des trois)
- Classe abstraite = au moins une fonction virtual pure (= 0)
- Fonction pure force dérivées à implémenter
- Sans virtual: liaison statique (méthode de Base toujours appelée)
- Avec virtual: liaison dynamique (méthode selon type réel appelée)


═══════════════════════════════════════════════════════════════════════════════
CONSEILS GÉNÉRAUX
═══════════════════════════════════════════════════════════════════════════════

1. FORME CANONIQUE
   Toujours implémenter les 4 éléments pour vos classes:
   - Constructeur par défaut
   - Constructeur par copie
   - Opérateur d'assignation (=)
   - Destructeur

2. GESTION MÉMOIRE
   - delete ce qui a été alloué par new
   - delete[] pour ce qui a été alloué par new[]
   - JAMAIS mélanger: new → delete, new[] → delete[]

3. RÉFÉRENCES
   - Utiliser & pour paramètres de fonctions (évite copies coûteuses)
   - Références pour relations obligatoires
   - Pointeurs pour relations optionnelles (peut être NULL)

4. const PARTOUT
   - const sur méthodes qui ne modifient pas l'objet
   - const& pour paramètres en lecture seule
   - const pour retours de getters

5. LISTE D'INITIALISATION
   - OBLIGATOIRE pour: références, attributs const
   - Plus efficace que assignation dans corps du constructeur
   - Syntaxe: Constructeur(params) : _attr1(val1), _attr2(val2) {}

6. INCRÉMENTATION
   - Préférer ++i à i++ (plus efficace)
   - Pré-incrémentation retourne référence
   - Post-incrémentation retourne copie

7. OPÉRATEUR D'ASSIGNATION
   - Toujours vérifier this != &other
   - Retourner *this pour permettre chaînage (a = b = c)
   - Libérer anciennes ressources avant d'en allouer de nouvelles

8. HÉRITAGE
   - protected pour attributs destinés aux classes dérivées
   - virtual public pour résoudre problème du diamant
   - Appeler constructeur de base dans liste d'initialisation

9. POLYMORPHISME (CRUCIAL!)
   - TOUJOURS virtual sur destructeur dans classe de base
   - virtual pour méthodes à override dans classes dérivées
   - Sans virtual: liaison statique (méthode de base appelée)
   - Avec virtual: liaison dynamique (méthode réelle appelée)

10. DEEP COPY
    - Obligatoire si classe a pointeurs vers mémoire dynamique
    - Implémenter: destructeur, copy constructor, assignment operator
    - Ne pas copier juste le pointeur (shallow copy = danger!)
    - Créer nouvelle allocation et copier le contenu

11. CLASSES ABSTRAITES
    - virtual void methode() = 0; rend fonction pure
    - Au moins une fonction pure = classe abstraite
    - Classe abstraite ne peut pas être instanciée
    - Force dérivées à implémenter les méthodes pures

12. ORGANISATION CODE
    - .hpp pour déclarations (class, prototypes)
    - .cpp pour implémentations
    - Inclure guards dans .hpp: #ifndef, #define, #endif

13. FUITES MÉMOIRE
    - Toujours delete dans destructeur
    - Utiliser valgrind pour vérifier
    - Tester avec pointeurs de base (Base* ptr = new Derivee())

14. TESTS
    - Tester forme canonique (copy, assignation)
    - Tester deep copy (modifier copie ne doit pas affecter original)
    - Tester polymorphisme (via Base*)
    - Tester destruction via Base* (vérifier virtual destructor)

15. BONNES PRATIQUES
    - Convention nommage: _attributPrive (underscore pour private/protected)
    - Initialiser tous les attributs dans constructeur
    - Documenter code complexe
    - Compiler avec -Wall -Wextra -Werror
    - Respecter la norme 42 (pas de using namespace std;, etc.)
